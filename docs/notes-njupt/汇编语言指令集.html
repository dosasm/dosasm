<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="DosAsm Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="DosAsm Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">3 汇编语言指令集 | DosAsm</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://dosasm.gitee.io/docs/notes-njupt/汇编语言指令集"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="3 汇编语言指令集 | DosAsm"><meta data-react-helmet="true" name="description" content="本文主要阐述主要的处理器指令，详细资料可以参考以下文档："><meta data-react-helmet="true" property="og:description" content="本文主要阐述主要的处理器指令，详细资料可以参考以下文档："><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://dosasm.gitee.io/docs/notes-njupt/汇编语言指令集"><link data-react-helmet="true" rel="alternate" href="https://dosasm.gitee.io/docs/notes-njupt/汇编语言指令集" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://dosasm.gitee.io/docs/notes-njupt/汇编语言指令集" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.823a8fb9.css">
<link rel="preload" href="/assets/js/runtime~main.e84f90be.js" as="script">
<link rel="preload" href="/assets/js/main.ffb5ba16.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/my-img/dosboxasm.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/my-img/dosboxasm.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">DosAsm</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">教程</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/references/README">参考</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/notes-njupt/总览">微机笔记</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://dosasm.gitee.io/dosrun" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>PlayGround<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://github.com/dosasm/dosasm" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/intro">DosAsm</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">VSCode插件</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">React应用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/awesome-assembly">汇编代码样例</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">参考信息</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">参考-微机原理与接口技术</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/总览">目录</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/微型计算机基础">1 微型计算机基础</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/02_80x86微处理器">2 80x86微处理器</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/notes-njupt/汇编语言指令集">3 汇编语言指令集</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/汇编语言程序设计">4 汇编语言程序</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/输入输出系统">7 输入/输出系统</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/中断系统">8 中断系统</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/串口通信">9 串口通信</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/并行IO接口">10 并行I/O 接口</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/可编程定时计数器">11 可编程定时器/计数器</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/ky">考研初试复习</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/notes-njupt/题目">题目</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>3 汇编语言指令集</h1></header><p>本文主要阐述主要的处理器指令，详细资料可以参考以下文档：</p><ol><li><a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html" target="_blank" rel="noopener noreferrer">Intel® 64 and IA-32 Architectures Software Developer Manuals</a><ol><li><code>Volume 1 1.3.2.1</code> Instruction Operands</li><li><code>Volume 2 (2A, 2B, 2C &amp; 2D)</code>: Instruction Set Reference, A-Z</li></ol></li><li><a href="https://archive.org/details/bitsavers_intel80486ataSheetApr89_12763574/page/n5/mode/2up" target="_blank" rel="noopener noreferrer">intel :: 80486 :: i486 Microprocessor Data Sheet Apr89 : Free Download, Borrow, and Streaming : Internet Archive</a><ol><li><code>2.2</code> Instruction Set</li></ol></li><li><a href="https://www.felixcloutier.com/x86/index.html" target="_blank" rel="noopener noreferrer">https://www.felixcloutier.com/x86/index.html</a></li></ol><p>本文也包括对汇编器伪指令、运算符、符号的介绍，详细指令可以参考以下文档：</p><ol><li><a href="https://docs.microsoft.com/en-us/cpp/assembler/masm/microsoft-macro-assembler-reference?view=msvc-160" target="_blank" rel="noopener noreferrer">Microsoft Macro Assembler reference | Microsoft Docs</a></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="概述"></a>概述<a class="hash-link" href="#概述" title="Direct link to heading">#</a></h2><p>处理器可以直接运行的指令是二进制的机器指令（例如下表第三列），为了方便阅读，使用符号指令来进行翻译（如下表的第二列），然而直接写符号指令还是过于抽象，所以需要“伪指令”来方便程序的编写。</p><ul><li>指令Instruction （指令常常会用操作码助记符Opcode mnemonic代指）CPU全部指令的集合，称为指令集(Instruction Set)。</li><li>伪指令Pseudo Instruction、命令Directives</li><li>运算符：Operator</li><li>符号：Symbol</li></ul><table><thead><tr><th>操作</th><th>486符号指令</th><th>486机器指令</th></tr></thead><tbody><tr><td>1234H→AX</td><td>MOV   AX, 1234H</td><td>B8   34 12</td></tr><tr><td>AX+BX→AX</td><td>ADD   AX, BX</td><td>03   C3</td></tr><tr><td>CX-DX→CX</td><td>SUB   CX, DX</td><td>2B   CA</td></tr><tr><td>返回调用程序</td><td>RET</td><td>C3</td></tr></tbody></table><ol><li><p><strong>指令</strong>：在某种计算机结构中定义的单个CPU操作，每条指令执行一个特定的操作。</p></li><li><p>指令的书写格式</p><ul><li>机器指令：用二进制格式的序列(一串0，1代码)书写。注意：硬件只能识别、存储和运行机器指令</li><li>符号指令：用字符串形式的序列(包含字符串形式的操作码以及操作数助记符)书写。</li></ul></li><li><p>指令的组成：<code>操作码+操作数</code></p><ul><li>操作码 —— 告诉计算机要执行的操作是什么，如：加、减、逻辑与等。</li><li>操作数 —— 执行操作过程所要操作的数，如加运算的两个加数。</li></ul></li><li><p><strong>指令长度</strong>：80X86指令长度(机器指令长度)为1～16字节</p><ul><li>规定：多字节指令占用连续的内存单元，存放指令第一字节的内存单元地址，称为“指令地址”。</li></ul></li><li><p>指令存放<strong>指令由操作码和操作数构成，存放在内存中</strong></p><ul><li>多字节操作数连续存放，顺序依据<strong>小端法规则</strong>(Little Endian)， 即：低位字节存放在低地址单元，高位字节存放在相邻的高地址单元。</li></ul></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="符号指令的书写格式"></a>符号指令的书写格式<a class="hash-link" href="#符号指令的书写格式" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">label: mnemonic argument1, argument2, argument3;comments</span></span><span class="token-line" style="color:#393A34"><span class="token plain">;例如</span></span><span class="token-line" style="color:#393A34"><span class="token plain">next: ADD AX,BX; 这是一条指令实例，表示AX+BX → AX</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><ul><li>Label标号<ul><li>以<strong>字母或下划线开头,后跟字母,数字,下划线,长度≤31字符</strong></li><li>标号又称符号地址,代表该指令的逻辑地址。可以忽略不写，但在设置为程序的转向目标时必须写出。</li><li>“系统保留字”<strong>不能</strong>做标号。</li></ul></li><li>(opcode) mnemonic (操作码)助记符<ul><li>a reserved name for a class of instruction opcodes which have the same function.</li></ul></li><li>Oprands(argument1, argument2, argument3...)操作数：表示指令的操作对象<ul><li>操作数 argument1, argument2, and argument3是可选的参数</li><li>当两个操作数位于算数或逻辑指令中时，右侧操作数称为源操作数，左侧称为目标操作数</li></ul></li><li>Comment注释<ul><li>以“;”开头，在汇编时不执行，打印程序清单时照原样打印</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="操作数及寻址方式"></a>操作数及寻址方式<a class="hash-link" href="#操作数及寻址方式" title="Direct link to heading">#</a></h2><p><em>操作数</em>是指令的操作对象。<em>寻址方式</em>就是在指令中，使用特定的助记符或助记符表达式(地址表达式)，告知CPU如何计算出操作数的地址，从而正确地取出操作数进行后继的指令操作. 计算出操作数地址的过程就是寻址。操作数包括：输入数据(状态)和输出数据(状态)。</p><p>在计算机硬件中，操作数被存放在三个区域，由此划分出三类七中具体的寻址方式</p><ul><li>CPU的寄存器：直接将数据存储在寄存器中</li><li>计算机的存储器：存储在指定地址的存储单元中</li><li>计算机接口电路中的端口</li></ul><p>CPU寄存器的内容整理在<a href="/docs/notes-njupt/02_80x86微处理器#32%E4%BD%8D%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84">第二章的寄存器部分</a></p><p><img alt="image-20200306194144959" src="/assets/images/image-20200306194144959-44e1968579873b85ffcd3f1e26406ddd.png"></p><p>在微型计算机中，操作数可能以如下四种方式存在：</p><ol><li><p>立即数Immediate Operand Mode:  <code>MOV  AX, 1234H</code></p><ul><li><p>操作数包含在指令中</p></li><li><p>立即数以数字开头，以Ａ～Ｆ开头的16进制数，必须前缀0。</p></li><li><p>立即数的数制用后缀表示,B表示二进制数,H表示十六进制数,D或缺省为十进制数，单引号括起来的字符编译成相应的ASCII码 。</p></li><li><p>可以用<code>+</code>,<code>–</code>,<code>*</code>,<code>/</code>组成立即数表达式</p></li><li><p>程序员可以按自己的习惯书写立即数，各种合法的立即数经汇编后，一律自动转换成等值的二进制数，负数用补码表示。</p></li></ul></li><li><p>寄存器数Register Operand Mode：<code>MOV  DS, AX</code></p><ul><li>操作数存放在CPU的某个寄存器中</li></ul></li><li><p>存储器数：操作数存放在存储器中</p><ol><li><strong>直接寻址</strong>Direct Mode: <code> INC Word PTR [500]</code><ol><li>包含在指令中的16位地址偏移量。</li></ol></li><li><strong>间接寻址</strong>Register Indirect Mode: <code>MOV EDX,[ECX] </code><ol><li>由CPU内部某个16位寄存器的内容决定，如 BX、BP、SI、DI。</li></ol></li><li><strong>基址</strong>Based Mode: <code>MOV ECX, [EAX + 24] </code><ol><li>基址寄存器BX或BP加上指令中包含的8位或16位位移量。</li></ol></li><li><strong>变址</strong>Scaled Mode:  <code>MOV AH,[4*EBX+3] </code><ol><li>变址寄存器SI或DI加上指令中包含的8位或16位位移量。</li></ol></li><li><strong>基址加变址</strong>Based Scaled Mode: <code>MOV AH,[EAX+4*EBX+3] </code><ol><li>由一个基址寄存器BX或BP加上一个变址寄存器SI或DI，再加上指令中包含的8位或16位位移量。</li></ol></li></ol></li><li><p>操作数存放在I/O端口中， 这种操作数称为<strong>I/O端口操作数</strong><code>IN  AL, 60H</code></p></li></ol><p>直接寻址和寄存器寻址是没有对应的逻辑段的。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="存储器操作数寻址方式"></a>存储器操作数寻址方式<a class="hash-link" href="#存储器操作数寻址方式" title="Direct link to heading">#</a></h3><p>在读写内存操作数之前，CPU必须知道相关存储单元的物理地址。</p><p>由于CPU对存储器采用分段管理, 因此指令格式中只能写出存放操作数的内存单元的“逻辑地址”。程序员的责任仅在于正确的书写逻辑地址<sup id="fnref-331"><a href="#fn-331" class="footnote-ref">331</a></sup>表达式，然后由CPU自动运算以求出物理地址。操作系统将程序调入内存时才给段寄存器赋实际值。此时，计算出的20位地址才是实际的物理地址。</p><p>直接寻址：</p><ul><li>表达式的格式1：段寄存器：[偏移地址]如：MOV   AL, ES:[2CH];MOV   AX, DS:[2000H]</li><li>表达式的格式2： 段寄存器:变量名<sup id="fnref-332"><a href="#fn-332" class="footnote-ref">332</a></sup></li></ul><p>借助寄存器来寻址：</p><ol><li><strong>间接寻址</strong>的地址表达式 <code>段寄存器：[间址寄存器]</code> <sup id="fnref-333"><a href="#fn-333" class="footnote-ref">333</a></sup>（某单元的物理地址=段寄存器内容×16+间址寄存器）</li><li><strong>基址</strong>寻址的地址表达式：<code>段寄存器:[基址寄存器+位移量]</code> <sup id="fnref-334"><a href="#fn-334" class="footnote-ref">334</a></sup></li><li><strong>变址</strong>:没有比例因子的变址寻址其地址表达式为： <code>段寄存器：[变址寄存器+位移量]</code></li><li><strong>基址加变址</strong>:无比例因子基址加变址地址表达式： <code>段寄存器：[基址寄存器+变址寄存器+位移量]</code><ol><li>基址寄存器和变址寄存器都是16位或都是32位，否则(16位寻址和32位寻址混合使用)是非法指令	</li><li>默认的段寄存器不一致，这样的组合虽然是合法，但容易出错</li><li>在不使用段超越前缀的情况下，规定：如果偏移地址中含有BP，则其缺省的段寄存器为SS；否则，其缺省的段寄存器为DS。</li></ol></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="约定访问逻辑段-省略段基址"></a>约定访问逻辑段 省略段基址<a class="hash-link" href="#约定访问逻辑段-省略段基址" title="Direct link to heading">#</a></h4><table><thead><tr><th>间址寄存器</th><th>约定访问的逻辑段</th><th align="center">适用于...</th></tr></thead><tbody><tr><td><strong>BP</strong></td><td><strong>堆栈段SS</strong></td><td align="center"><strong>16位寻址方式</strong></td></tr><tr><td><strong>BX,SI,DI</strong></td><td><strong>数据段DS</strong></td><td align="center"><strong>16位寻址方式</strong></td></tr></tbody></table><table><thead><tr><th>基址寄存器</th><th>约定访问的逻辑段</th><th></th></tr></thead><tbody><tr><td><strong>BP</strong></td><td><strong>堆栈段SS</strong></td><td><strong>16位寻址方式</strong></td></tr><tr><td><strong>BX</strong></td><td><strong>数据段DS</strong></td><td><strong>16位寻址方式</strong></td></tr></tbody></table><table><thead><tr><th>变址寄存器</th><th>约定访问的逻辑段</th><th>适用于……</th></tr></thead><tbody><tr><td><strong>SI,  DI</strong></td><td><strong>数据段DS</strong></td><td><strong>无比例因子,16位  寻址</strong></td></tr></tbody></table><p>对于基址加变址寻址，当基址寄存器为BX时，默认段约定寄存器为DS，当基址寄存器为BP时，默认段约定寄存器为SS。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="汇编语言语法"></a>汇编语言语法<a class="hash-link" href="#汇编语言语法" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="概述-1"></a>概述<a class="hash-link" href="#概述-1" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="1可执行文件的生成-microsoft-windows系统"></a>1.可执行文件的生成( Microsoft Windows系统)<a class="hash-link" href="#1可执行文件的生成-microsoft-windows系统" title="Direct link to heading">#</a></h4><p>汇编语言程序的开发过程（来自P141 4.2.3）</p><div class="mermaid">graph LR
A((汇编源程序))
B((.ASM文件))
C((.OBJ文件))
D((.EXE.COM可执行文件))
EDIT{编辑&lt;br/&gt;EDIT.EXE}
COMPILE{汇编 &lt;br/&gt; 编译TASM.EXE}
LINK{链接&lt;br/&gt;TLINK.EXE}
A--&gt;EDIT--&gt;B--&gt;COMPILE--&gt;C--&gt;LINK--&gt;D
edit(调编辑程序)--&gt;EDIT
compile(调汇编程序)--&gt;COMPILE
h(库文件)--&gt;LINK
link(调链接程序&lt;br/&gt;如TLINK.EXE)--&gt;LINK</div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="2汇编源程序中的语句类型和格式"></a>2.汇编源程序中的语句类型和格式<a class="hash-link" href="#2汇编源程序中的语句类型和格式" title="Direct link to heading">#</a></h4><p>汇编语言源程序包括的语句类型为：指令性语句和指示性语句。</p><ul><li><strong>指令性语句</strong>:即为通常所说的符号指令（经汇编后,其目标指令通知CPU进行什么操作）。指令性语句的格式就是符号指令的书写格式</li><li><strong>指示性语句</strong>:包括宏指令和伪指令<ul><li><strong>伪指令</strong>:是非机器指令，是在汇编期间进行操作的、为汇编程序，链接程序提供汇编链接信息</li><li><strong>宏指令</strong>:</li></ul></li></ul><p>两种汇编语言语句类型<strong>指令性语句（符号指令）</strong>和<strong>指示性语句（伪指令）</strong>对应的格式为：</p><table><thead><tr><th>语句对比</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>指令性语句</strong></td><td>标号：</td><td>操作码助记符</td><td>空格</td><td>操作数助记符(多个操作数之间用，隔开)</td><td>；注释</td></tr><tr><td><strong>指示性语句</strong></td><td>变量</td><td>伪指令助记符</td><td>空格</td><td>操作数项(多个操作数之间用，隔开)</td><td>；注释</td></tr></tbody></table><ol><li>变量名后没有冒号</li><li>不同的伪指令，操作数个数和类型不同</li><li>标号名、变量名、段名、过程名…命名规则:以除数字以外的字母或符号开头,后跟字母、数字，并且长度≤31个字符</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="常用伪指令"></a>常用伪指令<a class="hash-link" href="#常用伪指令" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="数据定义伪指令"></a>数据定义伪指令<a class="hash-link" href="#数据定义伪指令" title="Direct link to heading">#</a></h4><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="字节定义伪指令db"></a>字节定义伪指令DB<a class="hash-link" href="#字节定义伪指令db" title="Direct link to heading">#</a></h5><p><code>变量名 DB    一个或多个用逗号间隔的单字节数</code>DB是Define Byte 的缩写,“定义字节”。</p><ul><li>?  — 随机数, Dup ~ Duplicate(重复)</li><li>3 Dup(?) 代表3个用逗号间隔的随机数</li><li>5 Dup (&#x27;A&#x27;) 代表5个用逗号间隔的A的ASII码</li><li>用DB定义的这些内存单元(N1~ N1+12,N2~ N2+2)的属性均为“字节型”。</li></ul><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">N1     DB   12H,64,-1,3*3  ;N1是变量名是一个逻辑地址，占用一个字节</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       DB   01010101B,  ‘A’ , ‘B’</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       DB   0A6H, ‘ HELLO’</span></span><span class="token-line" style="color:#393A34"><span class="token plain">N2     DB   ?,?,?          ;与下条等价</span></span><span class="token-line" style="color:#393A34"><span class="token plain">N2     DB   3 DUP(?)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="字定义伪指令dw"></a>字定义伪指令DW<a class="hash-link" href="#字定义伪指令dw" title="Direct link to heading">#</a></h5><p> <code>变量名  DW 一个或多个用逗号间隔的双字节数</code>通知汇编程序把DW后跟的双字节数,依次存入从变量名开始的单元,每一个数占2个字节,存放时满足小端法规则，即：低位字节到低址单元,高位字节到相邻的高址单元。后面都满足此规则。8086字长为16</p><ul><li>DW — Define Word “字定义”</li><li>? — 双字节随机数</li><li>单引号中只能是一个或两个字符</li><li>用DW定义的这些单元的属性都是“字型”,如上例, WNUM ~ WNUM+11这12个单元的属性都是“字型”。</li></ul><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">WNUM   DW   1234H,56, ‘AB’, ‘C’;变量名是指向一个单元的逻辑地址</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       DW   ?,?</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       DW   2 DUP(?)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="双字定义伪指令dd"></a><strong>双字定义伪指令</strong>DD<a class="hash-link" href="#双字定义伪指令dd" title="Direct link to heading">#</a></h5><p><code>变量名 DD 一串用逗号间隔的4字节数</code></p><ul><li>用DD定义的这些单元的属性都是“双字型”，上例DNUM ~ DNUM+3单元，这些单元都是双字型单元。</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="多字节定义伪指令"></a>多字节定义伪指令<a class="hash-link" href="#多字节定义伪指令" title="Direct link to heading">#</a></h5><ul><li><code>变量名  DF  一串用逗号间隔的6字节数</code></li><li><code>变量名  DQ 一串用逗号间隔的8字节数</code></li><li><code>变量名  DT  一串用逗号间隔的10字节数</code></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="符号定义伪指令"></a>符号定义伪指令<a class="hash-link" href="#符号定义伪指令" title="Direct link to heading">#</a></h4><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="等值伪指令符号常数--equ-表达式"></a>等值伪指令<code>符号常数  EQU 表达式</code><a class="hash-link" href="#等值伪指令符号常数--equ-表达式" title="Direct link to heading">#</a></h5><ul><li>如:   NUM   EQU   33</li><li>功能: 定义符号常数NUM的值为33</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="等号伪指令符号常数--表达式"></a>等号伪指令<code>符号常数 = 表达式</code><a class="hash-link" href="#等号伪指令符号常数--表达式" title="Direct link to heading">#</a></h5><ul><li>如:  NUM = 33</li><li>功能:定义符号常数NUM的值为33</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="等值伪指令与等号伪指令的区别"></a>等值伪指令与等号伪指令的区别<a class="hash-link" href="#等值伪指令与等号伪指令的区别" title="Direct link to heading">#</a></h5><ul><li>用EQU定义的符号常数,其值在后继语句中不能更改</li><li>用“=”定义的符号常数,其值在后继语句中可以重新定义</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="常用运算符"></a>常用运算符<a class="hash-link" href="#常用运算符" title="Direct link to heading">#</a></h3><ol><li>算术运算符<code>+-\*/</code></li><li>关系运算符<code>EQ(等于), NE(不等于), GT(大于),LT(小于),GE(大于或等于)</code></li><li><code>$</code>运算符：汇编程序对源程序是逐行汇编的,​运算符可以返回汇编计数器的当前值。<ul><li><strong>应用</strong>：$运算符紧跟在 DB、DW、DD伪指令之后,统计字符串的长度。</li><li><strong>注意</strong>：空格也有ASCII码，为20H（32D）</li></ul></li><li><code>SEG</code>运算符<ul><li>格式: SEG 段名或变量名或标号名</li><li>功能: 计算某一逻辑段的段基址</li></ul></li><li><code>OFFSET</code>运算符<ul><li>格式：OFFSET  变量名或标号名</li><li>功能：算出逻辑段中某个变量或标号名所在单元相对于段首的偏移地址。</li></ul></li><li><code>PTR</code>运算符<ol><li>格式: <code>&lt;类型说明符&gt; PTR &lt;地址表达式&gt;</code>，如<code>BYTE PTR　VAR1</code></li><li>指令的操作数<strong>至少有一个</strong>类型属性要确定，否则必须用<code>PTR</code>运算符说明其中的内存操作数的类型</li><li>若两个操作数的类型属性都确定，则必须保持一致。否则必须用<code>PTR</code>运算符改变其中的内存操作数的类型，以保持前后属性一致。</li></ol></li><li>方括号运算符：用方括号括起来的地址表达式是访问内存操作数常用的寻址方式，方括号的另一用途是标注数组元素的下标，下标从0开始。
| 类型属性确定的操作数         | 类型属性不确定的操作数                       |
| ---------------------------- | -------------------------------------------- |
| 寄存器数                     | 立即数                                       |
| 用变量名直接寻址的内存操作数 | 间址、基址、变址、基加变址寻址的内存操作数数 |</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="ptr的具体应用方法"></a><code>PTR</code>的具体应用方法<a class="hash-link" href="#ptr的具体应用方法" title="Direct link to heading">#</a></h4><ul><li>在双操作数指令中(例如：<code>MOV</code>，<code>ADD</code>，<code>SUB</code>等指令)<ol><li>源操作数为<strong>立即数</strong>，目标操作数为<strong>(变量名)直接寻址的存储器操作数</strong>，当二者类型属性不一致时，后者必须用<code>PTR</code>临时修改其属性，使源目类型属性一致。</li><li>源操作数为<strong>立即数</strong>，目标操作数为<strong>间址、变址、基址或基址加变址寻址的存储器操作数</strong><sup id="fnref-3421"><a href="#fn-3421" class="footnote-ref">3421</a></sup>，<em>无论两者类型属性是否已经一致</em>，后者都必须用PTR显式说明其类型属性，使得源目操作数类型属性一致。</li><li><strong>源操作数和目标操作数中一方为寄存器操作数</strong>，另一方为直接寻址的存储器操作数，但二者类型属性不一致，必须用PTR临时修改其中的存储器操作数的属性。</li></ol></li><li>在单操作数指令中(例如：INC，DEC等指令)<ol><li>操作数为间址、变址、基址或基址加变址寻址的存储器操作数，必须用PTR说明是字节操作、字操作、还是双字操作，具体根据使用该条指令操作的意图。</li><li>操作数是直接寻址方式的存储器操作数，是否使用PTR要看操作数的类型属性要求是否与指令规定的操作数的类型属性一致(例如: PUSH指令)或者依据使用该条指令的操作意图。</li></ol></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="汇编语言基本指令集"></a>汇编语言基本指令集<a class="hash-link" href="#汇编语言基本指令集" title="Direct link to heading">#</a></h2><p>符号约定：</p><ul><li><code>N</code> 代表立即数，N8、N16、N32代表8、16、32位立即数</li><li><code>R</code> 代表寄存器操作数，R8、R16、R32代表8、16、32位寄存器操作数</li><li><code>M</code> 代表内存操作数，M8、M16、M32代表8、16、32位内存操作数</li><li><code>S</code> 代表段寄存器</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="总说明"></a>👉总说明<a class="hash-link" href="#总说明" title="Direct link to heading">#</a></h3><ol><li>对于双操作数指令（如：MOV,ADD,CMP...）<ol><li>源、目操作数<strong>不可同为内存操作数</strong></li><li>源、目操作数<strong>属性一致</strong>(长度相同)</li><li>当目标操作数为非变量名直接寻址的内存操作数，而源操作数为单字节/双字节立即数，则目标操作数必须用<code>PTR</code>说明类型</li></ol></li><li>对于单操作数指令（如：I NC,DEC...）
若操作数为间、变、基、基+变的内存操作数，则必须用PTR说明类型</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="传送类指令"></a>传送类指令<a class="hash-link" href="#传送类指令" title="Direct link to heading">#</a></h3><p>本类指令执行后，不影响状态标志</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="通用传送"></a>通用传送<a class="hash-link" href="#通用传送" title="Direct link to heading">#</a></h4><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="数据传送"></a>数据传送<a class="hash-link" href="#数据传送" title="Direct link to heading">#</a></h5><p>功能：源→目，源不变，不影响6种标志</p><ol><li>立即数不能直接送段寄存器   ~~ MOV DS, 3000H  ~~</li><li>目标操作数不允许用立即数方式   ~~ MOV 2000H, AL~~</li><li>不允许在两个存储单元间传送数据   <del>MOV[2000H],[3000H]</del></li><li>不允许在两个段寄存器之间传送数据   <del>MOV DS, ES</del></li><li>源、目属性要一致</li></ol><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">MOV   目标操作数  ，源操作数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      R / M     ，  N</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      R / M / S ，  R； 目标不允许是CS</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      R / M     ，  S</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      R / S     ，  M； 目标不允许是CS</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="符号扩展零扩展传送指令"></a>符号扩展/零扩展传送指令<a class="hash-link" href="#符号扩展零扩展传送指令" title="Direct link to heading">#</a></h5><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">MOVSX    目标寄存器，源操作数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">MOVZX    目标寄存器，源操作数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          R       ，R / M</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><ul><li>源操作数不变</li><li>源操作数字长要小于或等于目标寄存器字长</li><li>MOVSX  源操作数符号位向高位扩展，再送给目标</li><li>MOVZX  源操作数高位补零，再送给目标</li><li>变量名寻址的带有属性，需要考虑一致性问题</li></ul><p>例：</p><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">MOV        DL   ，-16   ；DL=F0H</span></span><span class="token-line" style="color:#393A34"><span class="token plain">MOVSX      BX   ，DL    ；BX=FFF0H，DL、DH不变</span></span><span class="token-line" style="color:#393A34"><span class="token plain">MOVZX      BX   ，DL    ；BX=00F0H，DL、DH不变</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="有效地址偏移地址传送"></a>有效地址(偏移地址)传送<a class="hash-link" href="#有效地址偏移地址传送" title="Direct link to heading">#</a></h5><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">LEA  REG, SRC</span></span><span class="token-line" style="color:#393A34"><span class="token plain">;(REG)&lt;-(SRC) 目的操作数&lt;-源操作数;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">;(16位通用寄存器)&lt;- (内存操作数)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><ul><li>该指令常用来设置一个16位的J寄存器作为地址指针；</li><li>该指令的执行效果与<code>MOV REG, OFFSET  SRC</code>相同。</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="交换指令xchg--oprd1-oprd2"></a>交换指令<code>XCHG  OPRD1, OPRD2</code><a class="hash-link" href="#交换指令xchg--oprd1-oprd2" title="Direct link to heading">#</a></h5><p>在寄存器间或寄存器与存储器间交换信息(不允许使用段寄存器)</p><ul><li>源操作数：  寄存器、存储器</li><li>目的操作数：寄存器、存储器</li><li>执行的操作：( OPRD1) <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em"></span><span class="mrel">↔</span></span></span></span></span>(OPRD2 )</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="查表指令x-lat----表头变量名"></a>查表指令<code>X LAT    表头变量名</code><a class="hash-link" href="#查表指令x-lat----表头变量名" title="Direct link to heading">#</a></h5><ul><li>该指令查找数据段中的字节表，即要求数据表放在数据段，每个表元素为单字节数</li><li>指令执行前：EBX或BX=表头的偏移地址    AL=表元素相对于表头的地址位移量</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="堆栈操作指令"></a>堆栈操作指令<a class="hash-link" href="#堆栈操作指令" title="Direct link to heading">#</a></h4><p>堆栈——按照 <strong>先进后出</strong>的原则组织的一段内存区域
堆栈指针SP的初值决定了堆栈的大小，SP始终指向堆栈的顶部，即始终指向最后推入堆栈的信息所在的单元。堆栈段寄存器SS存放堆栈区的段基址。堆栈指令一般不影响标志位</p><ul><li>SP栈顶：栈区的低地址，有进栈就变小，有出栈就变大</li><li>SS(?应该是BP吧)栈底：栈区的高地址，一般无变化</li></ul><ol><li>堆栈段寄存器SS：存放堆栈段<strong>段基址</strong></li><li>堆栈指针SP：存放<strong>栈顶</strong>单元的偏移地址</li><li>堆栈指针BP: 存放<strong>栈底</strong>单元的偏移地址</li><li>SS、SP初值由程序员赋值或DOS系统自 动赋值</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="进栈指令"></a>进栈指令<a class="hash-link" href="#进栈指令" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">;PUSH 源操作数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">;16 / N32</span></span><span class="token-line" style="color:#393A34"><span class="token plain">;S / R16 / R32 / M16 / M32</span></span><span class="token-line" style="color:#393A34"><span class="token plain">PUSH    WORD       PTR     [BX]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">PUSH    DWORD    PTR     [SI+5]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><p>说明：非直接寻址的内存操作数，必须用<code>PTR</code>说明属性</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="出栈指令"></a>出栈指令<a class="hash-link" href="#出栈指令" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">POP 目标操作数; R16 / R32 / M16 / M32 S(CS非法)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">PUSH AX</span></span><span class="token-line" style="color:#393A34"><span class="token plain">POP  BX；BX=AX</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><p>说明：非直接寻址的内存操作数，必须用<code>PTR</code>说明属性</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="pushf和popf指令"></a>PUSHF和POPF指令<a class="hash-link" href="#pushf和popf指令" title="Direct link to heading">#</a></h3><ul><li>16位标志寄存器入栈指令    <code>PUSHF</code><ul><li>功能：将16位标志寄存器 Flag 的内容压入堆栈保存。</li></ul></li><li>16位标志寄存器出栈指令    <code>POPF</code><ul><li>功能：把栈中内容弹出至16位标志寄存器 Flag。</li><li>注：该指令影响标志位 O、S、Z、A、P、C</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="算术运算类指令"></a>算术运算类指令<a class="hash-link" href="#算术运算类指令" title="Direct link to heading">#</a></h3><table><thead><tr><th>分类</th><th>名称</th><th>格式</th><th>功能</th><th>O S Z  A P C</th></tr></thead><tbody><tr><td>加法指令</td><td>加法指令</td><td>ADD  DST,SRC</td><td>加法（字、字节）</td><td>O S Z  A P C</td></tr><tr><td></td><td>带进位加法指令</td><td>ADC  DST,SRC</td><td>带进位加法(字、字节)</td><td>O S Z  A P C</td></tr><tr><td></td><td>加1 指令</td><td>INC  OPRD</td><td>加1（字、字节）</td><td>O S Z  A P</td></tr><tr><td>减法指令</td><td>SUB  DST,SRC</td><td>减法（字、字节）</td><td>O S Z  A P C</td><td></td></tr><tr><td></td><td>带借位减法指令</td><td>SBB  DST,SRC</td><td>带借位减法(字、字节)</td><td>O S Z  A P C</td></tr><tr><td></td><td>减1 指令</td><td>DEC  OPRD</td><td>减1（字、字节）</td><td>O S Z  A P</td></tr><tr><td></td><td>比较指令</td><td>CMP DST,SRC</td><td>比较（字、字节）</td><td>O S Z  A P C</td></tr><tr><td></td><td>求补指令</td><td>NEG  OPRD</td><td>求补码</td><td>O S Z  A P C</td></tr><tr><td>乘法指令</td><td>无符号数乘法</td><td>MUL  SRC</td><td>不带符号数乘法(字,字节)</td><td>O                C</td></tr><tr><td></td><td>带符号数乘法</td><td>IMUL  SRC</td><td>带符号数乘法(字,字节)</td><td>O                C</td></tr><tr><td>除法指令</td><td>无符号数除法</td><td>DIV  SRC</td><td>不带符号数除法(字,字节)</td><td>没有定义</td></tr><tr><td></td><td>带符号数乘法</td><td>IDIV  SRC</td><td>带符号数除法(字,字节)</td><td>没有定义</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="加法类指令"></a>加法类指令<a class="hash-link" href="#加法类指令" title="Direct link to heading">#</a></h4><ol><li><code>ADD DST,SRC``ADC DST,SRC</code><ul><li>源操作数：通用寄存器、存储器、立即数</li><li>目标操作数：通用寄存器、存储器</li><li>执行的操作：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mi>T</mi><mo>←</mo><mi>D</mi><mi>S</mi><mi>T</mi><mo>+</mo><mi>S</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">DST \leftarrow DST +SRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span></span>(<code>ADC</code>需要加上C标值)</li><li>注：该指令影响标志位；该指令适合有符号数和无符号数的运算（带符号数判O标）</li></ul></li><li><code>INC OPRD</code><ul><li>操作数：通用寄存器、存储器    (不能是段寄存器或立即数)</li><li>执行的操作：OPRD<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em"></span><span class="mrel">←</span></span></span></span></span> OPRD + 1</li><li>功能： 用于在循环中修改地址指针及循环次数等。</li><li>注：该指令影响标志位<ol><li>该指令将操作数视为无符号数；</li><li>该指令不影响 进位标志 C</li></ol></li></ul></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="减法类指令"></a>减法类指令<a class="hash-link" href="#减法类指令" title="Direct link to heading">#</a></h4><ol><li><code>SUB  DST,  SRC</code><ul><li>源操作数：通用寄存器、存储器、立即数</li><li>目的操作数：通用寄存器、存储器</li><li>执行的操作：DST<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em"></span><span class="mrel">←</span></span></span></span></span>DST - SRC</li><li>注：<ol><li>该指令影响标志位</li><li>该指令适合有符号数和无符号数的运算。</li></ol></li></ul></li><li><code>SBB  DST,  SRC</code><ul><li>源操作数：通用寄存器、存储器、立即数</li><li>目的操作数：通用寄存器、存储器</li><li>执行的操作：DST   DST - SRC –C</li><li>注：<ol><li>该指令影响标志位</li><li>该指令适合有符号数和无符号数的运算。</li></ol></li></ul></li><li><code>DEC  OPRD</code><ul><li>操作数：通用寄存器、存储器    (不能是段寄存器或立即数)</li><li>执行的操作：OPRD<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em"></span><span class="mrel">←</span></span></span></span></span>OPRD - 1</li><li>功能： 用于在循环中修改地址指针及循环次数等。</li><li>注：该指令影响标志位<ol><li>该指令将操作数视为无符号数；</li><li>该指令不影响 进位标志 C</li></ol></li></ul></li><li><code>NEG  OPRD</code><ul><li>操作数：通用寄存器、存储器</li><li>执行的操作：求补指令，将操作数按位取反后加1，再送回操作数。</li><li>注：<ol><li>该指令影响标志位</li></ol></li></ul></li><li><code>CMP  DST, SRC</code><ul><li>源操作数：通用寄存器、存储器、立即数</li><li>目的操作数：通用寄存器、存储器</li><li>注：<ol><li>该指令影响标志位</li><li>该指令同 SUB , 但其不保存运算结果；</li><li>该指令后面通常跟一条转移指令，根据标志位产生不同的程序分支。</li></ol></li></ul></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="乘法指令"></a>乘法指令<a class="hash-link" href="#乘法指令" title="Direct link to heading">#</a></h4><p><code>MUL   SRC</code> —— 无符号数乘法</p><ul><li>源操作数：通用寄存器、存储器(不能是立即数)</li><li>目的操作数：DX, AX (隐含)</li><li>执行的操作：<strong>SRC的类型决定是字或字节相除</strong><ul><li>字节操作<span class="math math-inline"><span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;$&#x27; in math mode at position 35: …AL)\times(SRC) $̲" style="color:#cc0000">(AH,AL)\leftarrow (AL)\times(SRC) $</span></span></li><li>字操作       <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mi>X</mi><mo separator="true">,</mo><mi>A</mi><mi>X</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi>A</mi><mi>X</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>S</mi><mi>R</mi><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(DX,AX)\leftarrow(AX)\times(SRC)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mclose">)</span></span></span></span></span>
注：该指令影响标志位
<code>IMUL   SRC</code> —— 带符号数乘法</li></ul></li><li>源操作数：通用寄存器、存储器(不能是立即数)</li><li>目的操作数：DX, AX (隐含)</li><li>执行的操作：<ul><li>字节操作  $ (AH,AL)\leftarrow(AL)\times(SRC)$</li><li>字操作       $ (DX,AX)\leftarrow (AX)\times(SRC)$
注：该指令影响标志位</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="除法指令"></a>除法指令<a class="hash-link" href="#除法指令" title="Direct link to heading">#</a></h4><p><code>DIV   SRC</code> —— 无符号数除法
<code>IDIV   SRC</code> —— 带符号数除法</p><ul><li>源操作数：通用寄存器、存储器  (不能是立即数)</li><li>目的操作数：DX, AX (隐含)</li><li>执行的操作：<ul><li>字节操作<ul><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>L</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi>A</mi><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>S</mi><mi>R</mi><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(AL)\leftarrow(AX) / (SRC)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mclose">)</span></span></span></span></span> —— 商</li><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>H</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi>A</mi><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>S</mi><mi>R</mi><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(AH) \leftarrow (AX) / (SRC)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.08125em">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mclose">)</span></span></span></span></span> —— 余数</li></ul></li><li>字操作<ul><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>X</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi>D</mi><mi>X</mi><mo separator="true">,</mo><mi>A</mi><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>S</mi><mi>R</mi><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(AX) \leftarrow (DX,AX) / (SRC)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mclose">)</span></span></span></span></span> —— 商</li><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mi>X</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi>D</mi><mi>X</mi><mo separator="true">,</mo><mi>A</mi><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>S</mi><mi>R</mi><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(DX)\leftarrow (DX,AX) / (SRC)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mclose">)</span></span></span></span></span> —— 余数
注：该指令对各标志位均无定义 。</li></ul></li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="bcd码调整指令"></a>BCD码调整指令<a class="hash-link" href="#bcd码调整指令" title="Direct link to heading">#</a></h4><ul><li>组合BCD码：一字节中含有2位BCD码。例：69的组合BCD码为69H</li><li>未组合BCD码：一字节中含有1位BCD码(高4位为0)。例：69的非组合BCD码为06H，09HBCD码调整指令</li></ul><table><thead><tr><th></th><th>BCD码调整指令</th><th></th></tr></thead><tbody><tr><td>加法</td><td>DAA AAA</td><td>前者为组合BCD码，后者为非组合BCD码</td></tr><tr><td>减法</td><td>DAS AAS</td><td>前者为组合BCD码，后者为非组合BCD码</td></tr><tr><td>乘法</td><td>AAM</td><td>未组合BCD码十进制乘法调整指令</td></tr><tr><td>除法</td><td>AAD</td><td>未组合BCD码十进制除法调整指令</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="转移类指令"></a>转移类指令<a class="hash-link" href="#转移类指令" title="Direct link to heading">#</a></h3><p><img alt="image-20200317161717734" src="/assets/images/image-20200317161717734-b957d0b648b4930d168fcb846d1e3bee.png"></p><p>转移指令分分类</p><table><thead><tr><th>按照转移条件分</th><th>按照转移范围分</th><th>按照获取转移地址的方法分</th></tr></thead><tbody><tr><td>无条件转移</td><td>段内转移</td><td>直接转移</td></tr><tr><td></td><td>段间转移</td><td>间接转移</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="无条件转移"></a>无条件转移<a class="hash-link" href="#无条件转移" title="Direct link to heading">#</a></h4><p><strong>功能</strong>：无条件转移，执行指定标号处的指令</p><table><thead><tr><th>--</th><th>直接转移</th><th>间接转移</th></tr></thead><tbody><tr><td>段内</td><td>JMP 标号<br>JMP SHORT 标号</td><td><code>JMP</code>寄存器操作数(不需要使用<code>ptr</code>）<br><code>JMP</code>内存操作数</td></tr><tr><td>段间</td><td>JMP 标号</td><td><code>JMP</code> 内存操作数</td></tr></tbody></table><ol><li>标号是转移地址标号</li><li>SHORT是短转移，其转移范围相对于指令地址而言在+129~-126个单元之间</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="有条件转移"></a>有条件转移<a class="hash-link" href="#有条件转移" title="Direct link to heading">#</a></h4><ul><li>一般格式:操作码助记符转移地址标号</li><li>应用:CMP       目，源条件转移指令</li><li>转移范围：转移到代码段任何位置</li><li>说明：操作码助记符隐含了转移的条件</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="按标志位的当前状态转移"></a>按标志位的当前状态转移<a class="hash-link" href="#按标志位的当前状态转移" title="Direct link to heading">#</a></h5><p>设转移地址标号为XYZ</p><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">JC       XYZ            ;当前C标志为1转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JNC      XYZ            ;当前C标志为0转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JZ       XYZ            ;当前Z标志为1转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JNZ      XYZ            ; 当前Z标志为0转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JS       XYZ            ;当前S标志为1转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JNS      XYZ            ;当前S标志为0转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JP       XYZ            ;当前P标志为1转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JNP      XYZ            ;当前P标志为0转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JO       XYZ            ;当前O标志为1转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JNO      XYZ            ;当前O标志为0转</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><p>无符号数条件转移应用：</p><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">CMP      N1,N2    ;N1,N2为无符号数无符号数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">;条件转移设：转移地址标号为XYZ则：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JA          XYZ ;N1 &gt; N2转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JNA         XYZ ;N1≤N2转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JC          XYZ ;N1 &lt; N2转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JNC         XYZ ;N1 ≥  N2转转移类指令</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><p>有符号数条件转移应用：</p><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">CMP   N1,N2;  N1,N2 为有符号数（机器数）有符号数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">;条件转移设：转移地址标号为XYZ则：</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> JG       XYZ      ；被减数的真值大于减数的真值转</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> JGE      XYZ      ；被减数的真值大于等于减数的真值转</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> JL       XYZ      ；被减数的真值小于减数的真值转</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> JLE      XYZ      ；被减数的真值小于等于减数的真值转转移类指令</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="循环控制转移"></a>循环控制转移<a class="hash-link" href="#循环控制转移" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">LOOP     XYZ     ；CX-1→ CX,  结果不为零转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">LOOPZ    XYZ     ；CX-1→ CX,  结果不为零,且Z标为1转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">LOOPNZ   XYZ     ；CX-1→ CX,  结果不为零,且Z标为0转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JCXZ     XYZ     ；测试CX, 若CX=0转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">JECXZ    XYZ     ；测试ECX, 若ECX=0转转移类指令</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><p>例：某班级40人，某课程考试成绩存放在SCORE开始的内存单元。请统计及格人数→OK单元。代码如下</p><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">;数据段：</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> SCORE    DB  ××, ...××；40 个成绩</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> OK       DB   ?</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> MOV    AX,SEG SCORE</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> MOV    DS,AX</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> MOV    BX,OFFSET SCORE</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> MOV    CX,40</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> MOV    DL,0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">LAST: CMP    BYTE   PTR  [BX],60</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> JC       NO</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> INC     DL</span></span><span class="token-line" style="color:#393A34"><span class="token plain">NO: INC BX</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> LOOP  LAST；DEC  CX    JNZ   LAST</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> MOV    OK, DL</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="子程序调用及返回指令"></a>子程序调用及返回指令<a class="hash-link" href="#子程序调用及返回指令" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">CALL  &lt;调用地址&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">RET</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><ul><li>调用：调用子程序，即无条件转到子程序的第一条指令</li><li>返回：返回断点，即返回到CALL的后继指令</li><li>子程序：能完成一定功能的相对独立的程序段</li></ul><p>汇编语言的子程序定义语句</p><div class="codeBlockContainer_2gih"><div class="codeBlockContent_3z4W assembly"><pre tabindex="0" class="prism-code language-assembly codeBlock_6upA thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_xlV7"><span class="token-line" style="color:#393A34"><span class="token plain">格式</span></span><span class="token-line" style="color:#393A34"><span class="token plain">子程序名  PROC  属性</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{子程序实体}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">RET</span></span><span class="token-line" style="color:#393A34"><span class="token plain">子程序名    ENDP</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_2e3i clean-btn">Copy</button></div></div><p>说明：</p><ul><li>子程序名：子程序名以字母开头，长度≤31</li><li>经汇编之后, 子程序名就是子程序第一条指令的地址。</li><li>PROC/ENDP 是子程序的定界语句</li><li>属性  有2种描述<ul><li>NEAR(或缺省)代表近子程序，即该子程序和调用它的那条指令在同一个代码段</li><li>FAR 代表远子程序，即该子程序和调用它的那条指令不在同一个代码段</li></ul></li><li>RET子程序返回指令</li></ul><p>子过程调用和返回</p><ul><li>CALL指令用于调用一个子过程<ul><li>子过程由程序员预先设计并装入内存；</li><li>子过程执行结束后要返回原调用处。</li></ul></li></ul><p>CALL调用指令的执行过程</p><ul><li>保护断点；将调用指令的下一条指令的地址(断点)压入堆栈</li><li>获取子程序的入口地址；子过程第1条指令的偏移地址即子程序的入口地址</li><li>执行子过程，含相应参数的保存及恢复；</li><li>恢复断点，返回原程序。将断点偏移地址由堆栈弹出</li></ul><table><thead><tr><th>分类</th><th>名称</th><th>指令</th><th>操作数</th><th>举例</th></tr></thead><tbody><tr><td>段内调用</td><td>直接调用</td><td><code>CALL ADDR</code></td><td>NEAR-标号</td><td><code>CALL CHANGE</code></td></tr><tr><td></td><td>间接调用</td><td><code>CALL WORD PTR OPRD</code></td><td>16位寄存器存储器</td><td><code>CALL BX</code></td></tr><tr><td>段间调用</td><td>直接调用</td><td><code>CALL FAR PTR ADDR</code></td><td>FAR-标号</td><td><code>CALL FAR PTR TRAN</code></td></tr><tr><td></td><td>间接调用</td><td><code>CALL DWORD PTR OPRD</code></td><td>存储器（32位）</td><td><code>CALL DWORD PTR[BX]</code></td></tr><tr><td>返回</td><td>返回</td><td><code>RET</code></td><td></td><td><code>RET</code></td></tr><tr><td></td><td>带立即数返回</td><td><code>RET EXP</code></td><td></td><td><code>RET 6</code></td></tr></tbody></table><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="段内调用"></a>段内调用<a class="hash-link" href="#段内调用" title="Direct link to heading">#</a></h5><p>被调用程序与调用程序在同一代码段。调用前只需保护断点的偏移地址</p><p>格式：<code>CALL NEAR PROC</code>PROC为近子程序名</p><p>执行过程：</p><ul><li>将断点的偏移地址压入堆栈</li><li>根据过程名定位至栈子程序入口</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="逻辑与移位运算指令"></a>逻辑与移位运算指令<a class="hash-link" href="#逻辑与移位运算指令" title="Direct link to heading">#</a></h3><table><thead><tr><th>分类</th><th>名称</th><th>格式</th><th>功能</th><th>O S Z   A P C</th></tr></thead><tbody><tr><td>逻辑运算指令</td><td>逻辑与指令</td><td>AND DST, SRC</td><td>与(字、字节)</td><td>O S Z   P C</td></tr><tr><td></td><td>逻辑或指令</td><td>OR DST, SRC</td><td>或(字、字节)</td><td>O S Z   P C</td></tr><tr><td></td><td>逻辑非指令</td><td>NOT OPRD</td><td>非(字、字节)</td><td>不影响</td></tr><tr><td></td><td>逻辑异或指令</td><td>XOR DST, SRC</td><td>异或(字、字节)</td><td>O S Z   P C</td></tr><tr><td></td><td>测试指令</td><td>TEST DST, SRC</td><td>测试(字、字节)</td><td>O S Z   P C</td></tr><tr><td>一般移位指令</td><td>逻辑左移指令</td><td>SHL OPRD, COUNT</td><td>逻辑左移(字、字节)</td><td>O S Z   P C</td></tr><tr><td></td><td>算术左移指令</td><td>SAL OPRD, COUNT</td><td>算术左移(字、字节)</td><td>O S Z   P C</td></tr><tr><td></td><td>逻辑右移指令</td><td>SHR OPRD, COUNT</td><td>逻辑右移(字、字节)</td><td>O S Z  P   C</td></tr><tr><td></td><td>算术右移移指令</td><td>SAR OPRD, COUNT</td><td>算术右移(字、字节)</td><td>O S Z  P C</td></tr><tr><td>循环移位指令</td><td>不含进位循环左移指令</td><td>ROL OPRD, COUNT</td><td>循环左移(字,字节)</td><td>O        C</td></tr><tr><td></td><td>不含进位循环右移指令</td><td>ROR OPRD, COUNT</td><td>循环右移(字,字节)</td><td>O        C</td></tr><tr><td></td><td>带进位循环左移指令</td><td>RCL OPRD, COUNT</td><td>带进位循环左移(字,字节)</td><td>O        C</td></tr><tr><td></td><td>带进位循环右移指令</td><td>RCR OPRD, COUNT</td><td>带进位循环右移(字,字节)</td><td>O        C</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="逻辑运算指令"></a>逻辑运算指令<a class="hash-link" href="#逻辑运算指令" title="Direct link to heading">#</a></h4><p><code>AND  DST,  SRC</code>  —— 逻辑与(可以使特定位置0)</p><ul><li>源操作数：通用寄存器、存储器、立即数</li><li>目的操作数：通用寄存器、存储器</li><li>执行的操作：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mi>T</mi><mo>←</mo><mi>D</mi><mi>S</mi><mi>T</mi><mstyle mathcolor="#cc0000"><mtext>\and</mtext></mstyle><mi>S</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">DST\leftarrow DST \and SRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\and</span></span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span></span></li><li>功能： 实现两个操作数的按位与运算。(将0标记某些位置置0)
注：该指令影响标志位,使 O=0, C=0,P, S, Z反映操作的结果。</li></ul><p><code>OR  DST,  SRC</code>  —— 逻辑或（可使特定位置1）</p><ul><li>源操作数：通用寄存器、存储器、立即数</li><li>目的操作数：通用寄存器、存储器</li><li>执行的操作：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mi>T</mi><mo>←</mo><mi>D</mi><mi>S</mi><mi>T</mi><mstyle mathcolor="#cc0000"><mtext>\or</mtext></mstyle><mi>S</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">DST \leftarrow DST \or SRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\or</span></span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span></span></li><li>功能： 实现两个操作数的按位或运算。（将1标记某些位置置1）
注：该指令影响标志位使 O=0, C=0,P, S, Z反映操作的结果。</li></ul><p><code>XOR  DST,  SRC</code>  —— 异或(使特定位取反)</p><ul><li>源操作数：通用寄存器、存储器、立即数</li><li>目的操作数：通用寄存器、存储器</li><li>执行的操作：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mi>T</mi><mo>←</mo><mi>D</mi><mi>S</mi><mi>T</mi><mtext> </mtext><mi>X</mi><mi>O</mi><mi>R</mi><mtext> </mtext><mi>S</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">DST \leftarrow DST \ XOR \ SRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span></span></li><li>功能： 实现两个操作数的按位异或运算。如果两个值不相同，则异或结果为1。如果两个值相同，异或结果为0。（用1异或取反用0异或保持不变）
注：该指令影响标志位使 O=0, C=0,P, S, Z反映操作的结果。</li></ul><p><code>TEST  DST,  SRC</code>  ——  测试</p><ul><li>源操作数：通用寄存器、存储器、立即数</li><li>目的操作数：通用寄存器、存储器</li><li>执行的操作： DST  AND SRC</li><li>功能： 实现两个操作数的按位与运算，结果不保存，只影响标志位。</li><li>注：该指令影响标志位使 O=0, C=0,P, S, Z反映操作的结果。</li></ul><p>TEST 通常用于检测一些条件是否满足，但又不希望改变原来操作数的情况，该指令后通常带有条件转移指令。</p><p><code>NOT   OPRD</code>  ——  逻辑非</p><ul><li>操作数：通用寄存器、存储器</li><li>执行的操作： $OPRD \leftarrow  NOT OPRD</li><li>功能： 实现操作数的按位取反运算。</li><li>注：该指令不影响标志位。</li><li>例如：  NOT  AL<br>NOT BYTE PTR [BX]</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="一般移位指令"></a>一般移位指令<a class="hash-link" href="#一般移位指令" title="Direct link to heading">#</a></h4><table><thead><tr><th>一般移位指令</th><th>示意图</th></tr></thead><tbody><tr><td>算术逻辑左移<code>SAL</code>，<code>SHL</code></td><td><img alt="image-20200317174122813" src="data:image/png;base64,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"></td></tr><tr><td>逻辑右移<code>SHR</code></td><td><img alt="image-20200317174522584" src="data:image/png;base64,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"></td></tr><tr><td>算术右移<code>SAR</code></td><td><img alt="image-20200317174755700" src="data:image/png;base64,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"></td></tr></tbody></table><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="左移"></a>左移<a class="hash-link" href="#左移" title="Direct link to heading">#</a></h5><p><code>SAL  OPRD, CNT</code>  ——  算术左移 <code>SHL  OPRD, CNT</code>   ——  逻辑左移</p><ul><li>操作数：通用寄存器、存储器</li><li>CNT：移位次数，只能是立即数或CL寄存器</li><li>注：该指令影响标志位</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="右移"></a>右移<a class="hash-link" href="#右移" title="Direct link to heading">#</a></h5><p><code>SHR  OPRD, CNT</code>   ——  逻辑右移（无符号数除2）</p><ul><li>操作数：通用寄存器、存储器</li><li>CNT：移位次数，只能是立即数或CL寄存器</li><li>注：该指令影响标志位</li></ul><p><code>SAR  OPRD, CNT</code>——  算术右移（有符号数除以2）</p><ul><li>操作数：通用寄存器、存储器</li><li>CNT：移位次数，只能是立即数或CL寄存器</li><li>注：该指令影响标志位</li></ul><p>移位指令的作用：
移位指令通常用来做 乘2 或 除2 的操作：左移一位        操作数×2 ;右移一位        操作数÷2</p><ul><li>算术移位指令适用于带符号数的运算。</li><li>逻辑移位指令适用于无符号数的运算。</li></ul><p><img alt="image-20200317175957309" src="/assets/images/image-20200317175957309-af89375da2c2377489f3e63cf1fae277.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="循环移位指令"></a>循环移位指令<a class="hash-link" href="#循环移位指令" title="Direct link to heading">#</a></h4><table><thead><tr><th>指令</th><th>执行的操作</th></tr></thead><tbody><tr><td>循环左移<code>ROL</code></td><td><img alt="循环左移" src="data:image/png;base64,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"></td></tr><tr><td>循环右移<code>ROR</code></td><td><img alt="循环右移" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAABICAMAAAA3fmJuAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABoVBMVEX///9AQEAAAADf39+vr69wcHB/f38QEBD/zc3/AAD8VFT5+fn+/v7/j4/+HBz4+Pj/V1f9OTn6+vr+zMz+cnL8/PzZp6fQ0NDT09PldXX3pKTq6urwSEjLy8vR0dH6GBj0wsLg4ODhjo77GRn19fX9/f3y8vLkkZHtRUXOzs7S0tL0MDDei4vcqqr2amrs7Oz7+/v/c3PToaHMzMzp6enz8/PxZWXrubn6UlLIyMju7u71oqLuRkbr6+v39/f9Gxv1TU3oeHj29vbrQ0Pa2trx8fHw8PD1MTHuvLzn5+fpXV3k5OTyLi73xcXJycn9y8vxLS3b29v7b2/hcXH8qane3t72o6P09PT/rKzlWVnsYGDl5eX+jo7kWFjqQkLV1dX8cHDSoKD4Fhb+VlbYhYXh4eH9cXHc3NzVo6P9VVXQnp7Wg4PNzc3U1NTt7e3ExMTPz8/UoqL8jIz3FRXv7+/Dw8PX19ftYWHah4ftu7vrmJj6iormWlr6bm7wgID0TEzPnZ3zS0v/Ozvo6OjwZGT5UVHvY2PKysrdi4vi4uLW1tY14U+1AAAAAWJLR0QAiAUdSAAAAAd0SU1FB+UMCgc1AmlgmOsAAANSSURBVGje7dnpV9NAEADwkCg4TaQSiY3UFpGm2iJSLVUoGjFyiGgVBSuKIHggWKAqeN+oiH+1k6SloE9IZRN4OvNpX4/M/nYnsylwXDEq+G0dFdymg+e2dfAkJCEJSUhCEpKQhCQkIQlJSEISeiLcml/260/P6XcdCrd44/hy50RCEpKQhCQkIQlJuDoED4WCQ6HAVLiD3+mZsJBrQ6GTOZUj5M3reSTk1xj/LNx4Tr+/WVm5znN6lVD8QqXrvyeqSrXKO5vTJhsHrldVpeDZHpq5nNTVhnMqQ2jn9Ea4xreO0MGcnE9YEDzspYLD/i78TS/djn/k2MwZTUISkpCEJCQhCUn4fwq3+D8z5c+Jo6Cg+IdjF5jhEyVuN9hR7Zf2FIZQg68Xxz5ZYprZzrW3VnEXiJZ9AXU/QJ2iBA8AhML1AAf9DfXm8BBAY0SLHgY4Eos3mZ9hmvhoQG0GONaScBN4HOBEsjWSOglwSky0AbSnOwBOn9HPAiTTqU6Ac4ZSB3C+q7unF+CCxhAYimHivt6L/Ql3S/RSeytmuIysFs0HkDGuAFwdkKsBYjp3DeB6UBtE4ZAo3cDPZBkV6k2A4UCPwklKx63bbgpHAO6oOg40vCe6REuIyUfH/LbwLsB4UcglACYaZDaJ7wHcf2DJEn1BN4UPUTgpmiMUPYpMmUIcTRf2ELGPcxGpIJRwFWb8bBLj5cdn7XpQXO00KBweKgrH0z6rZzbN5Wa1amvYmcwFNW6VMM9O+CTixVHxdEUI8Kx9HoULgXDyeVQxpzCH/fRFGle4JJxgJawBeOmJUMFOY1UptpzRvDFl9lLD8EvWIidf4aa9lleE5g3KqkrfALydlbwgvgNo1u07f2HA7jQrZRRLvUdiqUrRP82q04iNAHanGRnUXBXKHwBaNfNY/BhLSb8IDf0T3pXZQqepNdsOq9NCyuLidePFPvsWs67upWRMWi3lSygXHLFGX/E5jbOf2trEbD2U4ttSLMhsvbXgd+uiHZP9ortlKonz4bAaDwtRfGoby2VCaj8WotyghjKhmUU5Gsjk4vH80lIsHg8vZxk2diW7nA+r6o8W2fXbUdINDDNPwhzp5h5KfsN+0X7TDp3xyWynUzgKCgoKCsbxEzCce+H4LbbFAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTEyLTEwVDA3OjUyOjE5KzAwOjAw3CLLrAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0xMi0xMFQwNzo1MjoxMCswMDowMDjnNsMAAAAASUVORK5CYII="></td></tr><tr><td>带进位的循环左移<code>RCL</code></td><td><img alt="带进位的循环左移" src="data:image/png;base64,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"></td></tr><tr><td>带进位的循环右移<code>RCR</code></td><td><img alt="带进位的循环右移" src="data:image/png;base64,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"></td></tr></tbody></table><p><code>ROL  OPRD, CNT</code>   ——  循环左移</p><ul><li>操作数：通用寄存器、存储器</li><li>CNT：移位次数，只能是立即数或CL寄存器</li><li>注：该指令影响标志位</li></ul><p><code>ROR  OPRD, CNT</code>   ——  循环右移</p><ul><li>操作数：通用寄存器、存储器</li><li>CNT：移位次数，只能是立即数或CL</li><li>注：该指令影响标志位</li></ul><p><code>RCL  OPRD, CNT</code>   ——  带进位的循环左移</p><ul><li>操作数：通用寄存器、存储器</li><li>CNT：移位次数，只能是立即数或CL寄存器</li><li>注：该指令影响标志位</li></ul><p><code>RCR  OPRD, CNT</code>  ——  带进位的循环右移</p><ul><li>操作数：通用寄存器、存储器</li><li>CNT：移位次数，只能是立即数或CL寄存器</li><li>注：该指令影响标志位</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="串操作指令"></a>串操作指令<a class="hash-link" href="#串操作指令" title="Direct link to heading">#</a></h3><p>80X86有6条串操作指令,它们是串传送、串比较、串搜索、串装入、串存储和I/O串操作,本小节仅介绍前5条。</p><p>各种串操作指令虽然功能不同,但有许多共同之处:</p><ul><li>源串和目标串的存储及寻址方式都有隐含规定,即:源串要放在数据段,目标串要放在ES附加段</li><li>在16位寻址操作下,CPU自动用SI间址访问数据段,用DI间址访问ES附加段、用CX做为串计数器</li><li>操作是如果需要将操作其他段，可以通过段重叠的方法</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="串传送掌握原理！"></a>串传送(掌握原理！)<a class="hash-link" href="#串传送掌握原理！" title="Direct link to heading">#</a></h4><p>功能：把DS:[SI]的一个元素→ ES:[DI]的若干单元</p><ul><li>基本型格式：<ol><li>字节串传送 <code>MOVSB</code></li><li>字串传送          <code>MOVSW</code></li><li>双字串传送    <code>MOVSD</code></li></ol></li><li>说明：<ol><li>关于“元素”的概念<ul><li>在字节串传送指令中，一个元素就是1个字节</li><li>在字串传送指令中，一个元素为2个字节</li><li>在双字串传送指令中，一个元素为4个字节</li></ul></li><li>指令执行前的准备工作：<ul><li>源串的首地址/末地址→DS:SI</li><li>目串的首地址/末地址→ES:DI</li><li>D标志置0/置1; STD D标置1, CLD D标置0</li></ul></li><li>该指令传送一个元素后，CPU自动修改SI,DI<ul><li>当D标志为0时，SI,DI增量修改</li><li>当D标志为1时，SI,DI减量修改</li></ul></li></ol></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="串装入"></a>串装入<a class="hash-link" href="#串装入" title="Direct link to heading">#</a></h4><ul><li><code>LODSB</code> ;DS:[SI]的1个字节→AL,自动修改SI</li><li><code>LODSW</code> ;DS:[SI]的2个字节→AX,自动修改SI</li><li><code>LODSD</code> ;DS:[SI]的4个字节→EAX,自动修改SI
准备工作：串首址/末址→DS:SI, 0/1 →D标</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="串存储"></a>串存储<a class="hash-link" href="#串存储" title="Direct link to heading">#</a></h4><ol><li>基本型格式：<ul><li>STOSB ;AL →ES:[DI]的1个单元,自动修改DI</li><li>STOSW ;AX →ES:[DI]的2个单元,自动修改DI</li><li>STOSD ;EAX→ES:[DI]的4个单元,自动修改DI</li><li>准备工作：目标区首址/末址→ES:DI,0/1 →D标</li></ul></li><li>有<strong>重复前缀</strong>的格式<ul><li>REP    STOSB</li><li>REP    STOSW</li><li>REP    STOSD</li><li>准备工作：<ul><li>同基本型</li><li>欲存储的元素个数→CX</li></ul></li><li>功能：每存储一个元素，自动修改DI, 且CX-1→CX,CX=0时止</li></ul></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="串比较"></a>串比较<a class="hash-link" href="#串比较" title="Direct link to heading">#</a></h4><p>串比较：比较两串字符是否相等
两串字符对应字符相等，则两串字符相等，有一个字符不等，则两串字符不等</p><ol><li>基本型格式<ul><li>字节串比较 ：CMPSB</li><li>字串比较：CMPSW</li><li>双字比较：CMPSD</li><li>准备工作：<ul><li>源串首址/末址→DS:SI</li><li>目串首址/末址→ES:DI  ,0/1 →D标</li></ul></li></ul></li><li>有重复前缀的格式1
REPE     CMPSB
REPE     CMPSW
REPE     CMPSD</li><li>有重复前缀的格式2
REPNE   CMPSB
REPNE   CMPSW
REPNE   CMPSD</li></ol><ul><li>准备工作：<ul><li>同基本型</li><li>串元素的个数→ CX</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="串搜索"></a>串搜索<a class="hash-link" href="#串搜索" title="Direct link to heading">#</a></h4><p>在ES:[DI]的目标区，搜索是否有规定的“关键字”</p><ol><li>基本型格式<ul><li>SCASB</li><li>SCASW</li><li>SCASD</li><li>准备<ul><li>目标区首址/未址→ES:DI, 0/1 →D标</li><li>关键字→AL/AX/EAX</li></ul></li><li>功能：比较AL/AX/EAX=ES:[DI]? 若ES:[DI]=关键字，则Z置1，否则Z置0，修改DI</li></ul></li><li>有重复前缀的格式1：
REPE SCASB
REPE         SCASW
REPE SCASD</li><li>有重复前缀的格式2：
REPNE      SCASB
REPNE      SCASW
REPNE      SCASD</li></ol><ul><li>准备工作：同基本型</li><li>目标串元素的个数→ CX</li></ul><table><thead><tr><th></th><th><strong>字节操作</strong></th><th><strong>字 操  作</strong></th><th><strong>双字操作</strong></th></tr></thead><tbody><tr><td>D标志=0 为增址型</td><td>SI+1→SI <br>DI+1→DI</td><td>SI+2→SI<br> DI+2→DI</td><td>SI+4→SI <br>DI+4→DI</td></tr><tr><td>D标志=1 为减址型</td><td>SI-1→SI<br>   DI-1→DI</td><td>SI-2→SI   <br>   DI-2→DI</td><td>SI-4→SI <br>  DI-4→DI</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="处理及控制指令"></a>处理及控制指令<a class="hash-link" href="#处理及控制指令" title="Direct link to heading">#</a></h4><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="标志处理指令"></a>标志处理指令<a class="hash-link" href="#标志处理指令" title="Direct link to heading">#</a></h5><table><thead><tr><th>名称</th><th>格式</th><th>功能(对标志位的影响)</th></tr></thead><tbody><tr><td>进位标志清  0  指令</td><td>CLC</td><td>C = 0</td></tr><tr><td>进位标志置  1  指令</td><td>STC</td><td>C = 1</td></tr><tr><td>进位标志取反</td><td>CMC</td><td>C= C</td></tr><tr><td>方向标志清  0  指令</td><td>CLD</td><td>D = 0</td></tr><tr><td>方向标志置  1  指令</td><td>STD</td><td>D = 1</td></tr><tr><td>中断标志清  0  指令</td><td>CLI</td><td>I = 0</td></tr><tr><td>中断标志置  1  指令</td><td>STI</td><td>I = 1</td></tr></tbody></table><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="其他处理指令"></a>其他处理指令<a class="hash-link" href="#其他处理指令" title="Direct link to heading">#</a></h5><table><thead><tr><th>名称</th><th>格式</th><th>功能</th><th>状态标志位</th></tr></thead><tbody><tr><td>处理器等待指令</td><td>WAIT</td><td>处理器等待</td><td>不影响</td></tr><tr><td>处理器交权指令(换码指令)</td><td>ESC</td><td>处理器交权</td><td>不影响</td></tr><tr><td>总线封锁前缀</td><td>LOCK</td><td>封锁总线</td><td>不影响</td></tr><tr><td>处理器暂停指令</td><td>HLT</td><td>使处理器暂时处于停机状态</td><td>不影响</td></tr><tr><td>空操作指令</td><td>NOP</td><td>使CPU不进行任何操作</td><td>不影响</td></tr></tbody></table><p>例：串操作指令中，源串要放在 <code>数据</code> 段，在16位寻址操作下，CPU自动用寄存器   <code>SI</code>  间址访问该逻辑段，为了使执行串操作指令时地址按减量方式处理应使用指令   <code>STD</code>   。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="附录"></a>附录<a class="hash-link" href="#附录" title="Direct link to heading">#</a></h3><p>此外还有<a href="/docs/notes-njupt/输入输出系统###%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84I/O%E6%8C%87%E4%BB%A4">I/O指令</a>
中断相关指令</p><ul><li>开关中断<code>CLI</code> <code>STI</code></li><li>中断返回<code>IRET</code></li></ul><p>IRET和RET的区别如下：</p><ul><li>IRET从栈顶弹出6 个元素→ IP,CS,F</li><li>远程RET,从栈顶弹出4个元素→ IP,CS</li><li>近程RET,从栈顶弹出2个元素→ IP</li></ul><div class="footnotes"><hr><ol><li id="fn-331">逻辑地址形式——段寄存器:偏移地址<a href="#fnref-331" class="footnote-backref">↩</a></li><li id="fn-332">用变量名代表存储单元的偏移地址汇编语言允许为某单元起一个“名字”，这个名字就称为该单元的“变量名”，经汇编之后，变量名有段基址和偏移量两种属性。变量名是唯一的，程序中不能有重复的变量名。所以，“段寄存器：”可以省略。<a href="#fnref-332" class="footnote-backref">↩</a></li><li id="fn-333">访问约定的逻辑段时，省略段寄存器<a href="#fnref-333" class="footnote-backref">↩</a></li><li id="fn-334">物理地址=段寄存器内容×16+基址寄存器+位移量;访问约定的逻辑段，简化的地址表达式：<a href="#fnref-334" class="footnote-backref">↩</a></li><li id="fn-3421">有时也叫非变量名直接寻址的的操作数<a href="#fnref-3421" class="footnote-backref">↩</a></li></ol></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/dosasm/dosasm/edit/docusaurus/docs/notes-njupt/03_汇编语言指令集.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/notes-njupt/02_80x86微处理器"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 2 80x86微处理器</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/notes-njupt/汇编语言程序设计"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">4 汇编语言程序 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#概述" class="table-of-contents__link">概述</a><ul><li><a href="#符号指令的书写格式" class="table-of-contents__link">符号指令的书写格式</a></li></ul></li><li><a href="#操作数及寻址方式" class="table-of-contents__link">操作数及寻址方式</a><ul><li><a href="#存储器操作数寻址方式" class="table-of-contents__link">存储器操作数寻址方式</a></li></ul></li><li><a href="#汇编语言语法" class="table-of-contents__link">汇编语言语法</a><ul><li><a href="#概述-1" class="table-of-contents__link">概述</a></li><li><a href="#常用伪指令" class="table-of-contents__link">常用伪指令</a></li><li><a href="#常用运算符" class="table-of-contents__link">常用运算符</a></li></ul></li><li><a href="#汇编语言基本指令集" class="table-of-contents__link">汇编语言基本指令集</a><ul><li><a href="#总说明" class="table-of-contents__link">👉总说明</a></li><li><a href="#传送类指令" class="table-of-contents__link">传送类指令</a></li><li><a href="#pushf和popf指令" class="table-of-contents__link">PUSHF和POPF指令</a></li><li><a href="#算术运算类指令" class="table-of-contents__link">算术运算类指令</a></li><li><a href="#转移类指令" class="table-of-contents__link">转移类指令</a></li><li><a href="#逻辑与移位运算指令" class="table-of-contents__link">逻辑与移位运算指令</a></li><li><a href="#串操作指令" class="table-of-contents__link">串操作指令</a></li><li><a href="#附录" class="table-of-contents__link">附录</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/references/README">References</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/dosasm" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/dosasm/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://docusaurus.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Docusaurus<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://js-dos.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Js-Dos<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 DosAsm Project. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.e84f90be.js"></script>
<script src="/assets/js/main.ffb5ba16.js"></script>
</body>
</html>